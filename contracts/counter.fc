#include "imports/stdlib.fc";

;;
;;  Storage
;;
;;  uint32 id
;;  uint32 id
;;  MsgAddressInt latest_address
;;  MsgAddressInt owner_address
;;

;; OPCODEs
;; CRC32 Hashing Tool : https://docs.ton.org/develop/data-formats/crc32
const op::up = "op::up"c;
const op::down = "op::down"c;
const op::reset = "op::reset"c;
const op::deposit = "op::deposit"c;
const op::withdraw = "op::withdraw"c;

;; 
const const::min_tons_for_storage = 10000000; ;; 0.01 TON

;; ERRORs
const error::unauthorized = 403;
const error::not_enough_balance = 400;

(int, int, slice, slice) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_uint(32),
        ds~load_uint(32),
        ds~load_msg_addr(),
        ds~load_msg_addr()
    );
}

() save_data(int counter_id, int counter_value, slice sender_address, slice owner_address) impure inline {
    set_data(
            begin_cell()
                .store_uint(counter_id, 32)
                .store_uint(counter_value, 32)
                .store_slice(sender_address)
                .store_slice(owner_address)
                .end_cell()
        );
}

() recv_internal(cell in_msg_full, slice in_msg_body) {
    ;; load sender msg
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    int op = in_msg_body~load_uint(32);

    ;; load data from sender cell
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }
    slice sender_address = cs~load_msg_addr();

    ;; load data from current cell
    slice ds = get_data().begin_parse();
    var (counter_id, counter_value, _, owner_address) = load_data();

    if (op == op::up) {
        save_data(counter_id, counter_value + 1, sender_address, owner_address);
        return ();
	}

    if (op == op::down) {
        save_data(counter_id, counter_value - 1, sender_address, owner_address);
        return ();
    }

    if (op == op::reset) {
        save_data(counter_id, 0, sender_address, owner_address);
        return ();
    }

    if (op == op::withdraw) {
        ;; check access right
        throw_unless(error::unauthorized, equal_slices(sender_address, owner_address));

        int withdraw_amount = in_msg_body~load_coins();
        var [balance, _] = get_balance();
        throw_unless(error::not_enough_balance, balance >= withdraw_amount);

        ;; keep minimum ton for storage
        int return_value = min(withdraw_amount, balance - const::min_tons_for_storage);

        ;; sending internal message
        ;; https://docs.ton.org/develop/smart-contracts/messages
        cell msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(sender_address)
            .store_coins(return_value)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            ;; .store_slice(message_body)
            .end_cell();

        int msg_mode = 1; ;; 0 (Ordinal Message) + 1 (Pay transfer seperately)
        
        send_raw_message(msg, msg_mode);
        return ();
    }

    if (op == op::deposit) {
        return ();
    }

    throw(0xffff);
}

(int, int, slice, slice) get_contract_storage_data() method_id {
  return load_data();
}

int balance() method_id {
    var [balance, _] = get_balance();
    return balance;
}