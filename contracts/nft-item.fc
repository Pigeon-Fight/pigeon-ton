;;
;;  TON NFT Item Smart Contract v2
;;  support ownership_assigned on minting nft
;;


;;
;;  Storage
;;
;;  uint64 index
;;  uint8  class
;;;;  Stats
;;  uint16 exp
;;  uint16 allocated_point
;;  uint16 stat_atk
;;  uint16 stat_def
;;  uint16 stat_spd
;;  uint16 max_hp
;;  uint16 max_energy
;;;; 112 bits

;;  MsgAddressInt collection_address
;;  MsgAddressInt owner_address
;;

#include "imports/stdlib.fc";
#include "imports/op-codes.fc";
#include "imports/params.fc";

int min_tons_for_storage() asm "50000000 PUSHINT"; ;; 0.05 TON
int workchain() asm "0 PUSHINT";

;; Opcodes
const op::upgrade = "op::upgrade"c;
const op::battle = "op::battle"c;
const op::accept_battle = "op::accept_battle"c;

;; Constants
const const::min_tons_for_storage = 10000000; ;; 0.01 TON
const const::uint16_max = 65535;
const const::uint24_max = 16777215;
const const::base_exp = 10;

;; Errors
const error::unauthorized = 401;
const error::not_enough_balance = 402;
const error::deploy_failed = 405;
const error::invalid_points = 406;

(int, int, slice, int, slice, slice) load_data() {
    slice ds = get_data().begin_parse();
    var (class, stats) = (ds~load_uint(8), ds~load_bits(112));
    var (index, collection_address) = (ds~load_uint(64), ds~load_msg_addr());
    if (ds.slice_bits() > 0) {
      return (-1, class, stats, index, collection_address, ds~load_msg_addr());
    } else {
      return (0, class, stats, index, collection_address, null()); ;; nft not initialized yet
    }
}

() store_data(int index, int class, slice stats, slice collection_address, slice owner_address) impure {
    set_data(
        begin_cell()
            .store_uint(index, 64)
            .store_uint(class, 8)
            .store_slice(stats)
            .store_slice(collection_address)
            .store_slice(owner_address)
            .end_cell()
    );
}

int exp_to_point(int exp) inline {
  return 3 * (exp - const::base_exp) / 50;
}

int safe_add_16(int a, int b) inline {
    if (a > const::uint16_max - b) {
        return const::uint16_max;
    }
    return a + b; 
}

() send_msg(slice to_address, int amount, int op, int query_id, builder payload, int send_mode) impure inline {
  var msg = begin_cell()
    .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
    .store_slice(to_address)
    .store_coins(amount)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_uint(op, 32)
    .store_uint(query_id, 64);

  if (~ builder_null?(payload)) {
    msg = msg.store_builder(payload);
  }

  send_raw_message(msg.end_cell(), send_mode);
}

() transfer_ownership(int my_balance, int class, slice stats, int index, slice collection_address, slice owner_address, slice sender_address, int query_id, slice in_msg_body, int fwd_fees) impure inline {
    throw_unless(error::unauthorized, equal_slices(sender_address, owner_address));

    slice new_owner_address = in_msg_body~load_msg_addr();
    force_chain(new_owner_address);
    slice response_destination = in_msg_body~load_msg_addr();
    in_msg_body~load_int(1); ;; this nft don't use custom_payload
    int forward_amount = in_msg_body~load_coins();

    int rest_amount = my_balance - min_tons_for_storage();
    if (forward_amount) {
      rest_amount -= (forward_amount + fwd_fees);
    }
    int need_response = response_destination.preload_uint(2) != 0; ;; if NOT addr_none: 00
    if (need_response) {
      rest_amount -= fwd_fees;
    }

    throw_unless(error::not_enough_balance, rest_amount >= 0); ;; base nft spends fixed amount of gas, will not check for response

    if (forward_amount) {
      send_msg(new_owner_address, forward_amount, op::ownership_assigned(), query_id, begin_cell().store_slice(owner_address).store_slice(in_msg_body), 1);  ;; paying fees, revert on errors
    }
    if (need_response) {
      force_chain(response_destination);
      send_msg(response_destination, rest_amount, op::excesses(), query_id, null(), 1); ;; paying fees, revert on errors
    }

    store_data(index, class, stats, collection_address, new_owner_address);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }
    slice sender_address = cs~load_msg_addr();

    cs~load_msg_addr(); ;; skip dst
    cs~load_coins(); ;; skip value
    cs~skip_bits(1); ;; skip extracurrency collection
    cs~load_coins(); ;; skip ihr_fee
    int fwd_fee = muldiv(cs~load_coins(), 3, 2); ;; we use message fwd_fee for estimation of forward_payload costs

    (int init?, int class, slice stats, int index, slice collection_address, slice owner_address) = load_data();
    if (~ init?) {
      throw_unless(error::deploy_failed, equal_slices(collection_address, sender_address));
      var new_owner_address = in_msg_body~load_msg_addr();
      store_data(index, class, stats, collection_address, new_owner_address);
      if (in_msg_body.slice_data_empty?() == false) {
        var forward_amount = in_msg_body~load_coins();
        if (forward_amount) {
          send_msg(new_owner_address, forward_amount, op::ownership_assigned(), 0, begin_cell().store_slice(collection_address).store_slice(in_msg_body), 3); ;; paying fees, ignore errors
        }
      }
      return ();
    }

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    if (op == op::transfer()) {
      transfer_ownership(my_balance, class, stats, index, collection_address, owner_address, sender_address, query_id, in_msg_body, fwd_fee);
      return ();
    }
    if (op == op::get_static_data()) {
      send_msg(sender_address, 0, op::report_static_data(), query_id, begin_cell().store_uint(index, 256).store_slice(collection_address), 64);  ;; carry all the remaining value of the inbound message
      return ();
    }
    if (op == op::upgrade) {
      ;; update allocated_point
      int exp = stats~load_uint(16);
      int total_point = exp_to_point(exp);
      int allocated_point = stats~load_uint(16);

      int atk_point = in_msg_body~load_uint(16);
      int def_point = in_msg_body~load_uint(16);
      int spd_point = in_msg_body~load_uint(16);
      int max_hp_point = in_msg_body~load_uint(16);
      int max_energy_point = in_msg_body~load_uint(16);
      int total_new_point = atk_point + def_point + spd_point + max_hp_point + max_energy_point;

      throw_unless(error::invalid_points, total_new_point <= total_point - allocated_point);
      allocated_point = allocated_point + total_new_point;

      int atk = safe_add_16(stats~load_uint(16), atk_point);
      int def = safe_add_16(stats~load_uint(16), def_point);
      int spd = safe_add_16(stats~load_uint(16), spd_point);
      int max_hp = safe_add_16(stats~load_uint(16), max_hp_point);
      int max_energy = safe_add_16(stats~load_uint(16), max_energy_point);

      slice new_stats = begin_cell()
            .store_uint(exp, 16)
            .store_uint(allocated_point, 16)
            .store_uint(atk, 16)
            .store_uint(def, 16)
            .store_uint(spd, 16)
            .store_uint(max_hp, 16)
            .store_uint(max_energy, 16)
            .end_cell().begin_parse();

      ;; evolution
      if (class <= 36) {
        ;; second evolution
        if (class <= 18) {
          if (allocated_point >= 310) {
            class = class * 2;
          }
        }
        ;; first evolution
        if (class <= 10) {
          if (allocated_point >= 160) {
            class = class * 2;
          }
        }
      }

      store_data(index, class, new_stats, collection_address, owner_address);
    }

    throw(0xffff);
}

cell number_to_ascii_cell(int class) {
  int tens = class / 10;
  int units = class % 10;

  var ds = begin_cell();
  if (tens > 0) {
    ds.store_uint(tens + 48, 8);
  }
  ds.store_uint(units + 48, 8).end_cell();

  return ds.store_uint(units + 48, 8).end_cell();
}

;;
;;  GET Methods
;;

(int, int, slice, slice, cell) get_nft_data() method_id {
  (int init?, int class, slice stats, int index, slice collection_address, slice owner_address) = load_data();
  return (init?, index, collection_address, owner_address, number_to_ascii_cell(class));
}