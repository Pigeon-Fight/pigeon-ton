#include "imports/stdlib.fc";

;;
;;  Storage
;;
;; storage#_ 
;;           nft_collection_address:MsgAddressInt
;;           owner_address:MsgAddressInt
;;           prices:(dict 8 int128)
;;         = SaleStorage
;;

;; OPCODEs
;; CRC32 Hashing Tool : https://docs.ton.org/develop/data-formats/crc32
const op::purchase = "op::purchase"c;
const op::withdraw = "op::withdraw"c;
const op::update_price = "op::update_price"c;

;; CONSTANTs
int min_tons_for_storage() asm "50000000 PUSHINT"; ;; 0.05 TON
int tons_in_nft_item() asm "50000000 PUSHINT"; ;; 0.05 TON
const const::initial_points = 10;

;; ERRORs
const error::unauthorized = 403;
const error::not_enough_balance = 400;
const error::not_exist = 404;
const error::invalid_points = 401;

(slice, slice, cell) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_msg_addr(),
        ds~load_msg_addr(),
        ds~load_ref()
    );
}

cell number_to_ascii_cell(int class) {
  int tens = class / 10;
  int units = class % 10;

  var ds = begin_cell();
  if (tens > 0) {
    ds.store_uint(tens + 48, 8);
  }
  ds.store_uint(units + 48, 8).end_cell();

  return ds.store_uint(units + 48, 8).end_cell();
}

() save_data(slice nft_collection_address, slice owner_address, cell price_dict) impure inline {
    set_data(
            begin_cell()
                .store_slice(nft_collection_address)
                .store_slice(owner_address)
                .store_ref(price_dict)
                .end_cell()
        );
}

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) {
    ;; load sender msg
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    int op = in_msg_body~load_uint(32);

    ;; load data from sender cell
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }
    slice sender_address = cs~load_msg_addr();

    ;; load data from current cell
    slice ds = get_data().begin_parse();
    var (nft_collection_address, owner_address, price_dict) = load_data();

    ;; opcode - purchase
    if (op == op::purchase) {
        ;; load input
        int class = in_msg_body~load_uint(8);
        var (price_slice, found) = udict_get?(price_dict, 8, class);
        throw_unless(error::not_exist, found);

        ;; Convert slice to price int128
        int price = price_slice.preload_int(128);

        ;; check price
        throw_unless(error::not_enough_balance, msg_value > price + tons_in_nft_item());
        int send_value = msg_value - price;

        ;; validate initial nft attributes
        int attack = in_msg_body~load_uint(8);
        int defense = in_msg_body~load_uint(8);
        int speed = in_msg_body~load_uint(8);
        throw_unless(error::invalid_points, const::initial_points == attack + defense + speed);
        
        ;; sending internal message
        ;; https://docs.ton.org/develop/smart-contracts/messages
        cell nft_content = begin_cell()
                    .store_slice(sender_address)
                    .store_ref(number_to_ascii_cell(class))
                    .end_cell();
        cell msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(nft_collection_address)
            .store_coins(send_value)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            ;; body
            .store_uint(1, 32) ;; opcode: deploy nft
            .store_uint(0, 64) ;; query_id
            .store_coins(tons_in_nft_item()) ;; coins_amount
            .store_ref(nft_content) ;; nft_content
            ;; end
            .end_cell();

        int msg_mode = 16; ;; 0 (Ordinal Message) + 16 (bounce the message on error)
        
        send_raw_message(msg, msg_mode);
        return ();
    }

    ;; opcode - withdraw
    if (op == op::withdraw) {
        ;; check access right
        throw_unless(error::unauthorized, equal_slices(sender_address, owner_address));

        int withdraw_amount = in_msg_body~load_coins();
        var [balance, _] = get_balance();
        throw_unless(error::not_enough_balance, balance >= withdraw_amount);

        ;; keep minimum ton for storage
        int return_value = min(withdraw_amount, balance - min_tons_for_storage());

        ;; sending internal message
        ;; https://docs.ton.org/develop/smart-contracts/messages
        cell msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(sender_address)
            .store_coins(return_value)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            ;; .store_slice(message_body)
            .end_cell();

        int msg_mode = 1; ;; 0 (Ordinal Message) + 1 (Pay transfer seperately)
        
        send_raw_message(msg, msg_mode);
        return ();
    }

    ;; opcode - update price
    if (op == op::update_price) {
        ;; check access right
        throw_unless(error::unauthorized, equal_slices(sender_address, owner_address));

        var (class, new_price) = (in_msg_body~load_uint(8), in_msg_body~load_coins());
        udict_set(price_dict, 8, class, begin_cell().store_int(new_price, 128).end_cell().begin_parse());
        
        save_data(
            nft_collection_address, owner_address, price_dict
        );
    }

    throw(0xffff);
}


;;
;;  GET Methods
;;

(slice, slice, cell) get_contract_data() method_id {
  return load_data();
}

int balance() method_id {
    var [balance, _] = get_balance();
    return balance;
}